package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// TestModulePathAggregationBugFix verifies that the bug where module imports with paths
// were not properly aggregated is fixed
func TestModulePathAggregationBugFix(t *testing.T) {
	// Create a temporary test directory
	tempDir, err := os.MkdirTemp("", "node-modules-aggregation-bug-test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Create package.json with test modules
	pkgJsonContent := `{
  "dependencies": {
    "test-module": "^1.0.0",
    "@org/scope-module": "^2.0.0",
    "simple-module": "^3.0.0"
  }
}`
	pkgJsonPath := filepath.Join(tempDir, "package.json")
	err = os.WriteFile(pkgJsonPath, []byte(pkgJsonContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	// Create test files with different import paths for the same modules
	file1Content := `import "test-module";
import "test-module/src/path1";
import "test-module/lib/utils";
import "@org/scope-module";
import "@org/scope-module/components/Button";
console.log("file1");`
	file1Path := filepath.Join(tempDir, "file1.ts")
	err = os.WriteFile(file1Path, []byte(file1Content), 0644)
	if err != nil {
		t.Fatalf("Failed to write file1.ts: %v", err)
	}

	file2Content := `import "test-module";
import "test-module/src/path2";
import "test-module/dist/index";
import "simple-module";
import "simple-module/helpers";
console.log("file2");`
	file2Path := filepath.Join(tempDir, "file2.ts")
	err = os.WriteFile(file2Path, []byte(file2Content), 0644)
	if err != nil {
		t.Fatalf("Failed to write file2.ts: %v", err)
	}

	file3Content := `import "@org/scope-module";
import "@org/scope-module/types";
import "simple-module";
console.log("file3");`
	file3Path := filepath.Join(tempDir, "file3.ts")
	err = os.WriteFile(file3Path, []byte(file3Content), 0644)
	if err != nil {
		t.Fatalf("Failed to write file3.ts: %v", err)
	}

	// Test 1: Basic flat list should show only unique module names
	result, count := NodeModulesCmd(
		tempDir,
		false, // ignoreType
		[]string{}, // entryPoints
		false, // countFlag
		false, // listUnused
		false, // listMissing
		false, // groupByModule
		false, // groupByFile
		false, // groupByModuleFilesCount
		[]string{}, // pkgJsonFieldsWithBinaries
		[]string{}, // filesWithBinaries
		[]string{}, // filesWithModules
		[]string{}, // modulesToInclude
		[]string{}, // modulesToExclude
		"", // packageJson
		"", // tsconfigJson
		[]string{}, // conditionNames
		FollowMonorepoPackagesValue{}, // followMonorepoPackages
	)

	// Should show exactly 3 unique modules (aggregated)
	expectedModules := []string{"@org/scope-module", "simple-module", "test-module"}
	resultLines := strings.Split(strings.TrimSpace(result), "\n")
	
	if len(resultLines) != 3 {
		t.Errorf("Expected 3 unique modules, got %d: %v", len(resultLines), resultLines)
	}
	
	for _, expected := range expectedModules {
		found := false
		for _, line := range resultLines {
			if strings.TrimSpace(line) == expected {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Expected module '%s' not found in result: %s", expected, result)
		}
	}

	if count != 3 {
		t.Errorf("Expected count 3, got %d", count)
	}

	// Test 2: Group by module should show all files under each module
	resultGrouped, _ := NodeModulesCmd(
		tempDir,
		false, // ignoreType
		[]string{}, // entryPoints
		false, // countFlag
		false, // listUnused
		false, // listMissing
		true, // groupByModule
		false, // groupByFile
		false, // groupByModuleFilesCount
		[]string{}, // pkgJsonFieldsWithBinaries
		[]string{}, // filesWithBinaries
		[]string{}, // filesWithModules
		[]string{}, // modulesToInclude
		[]string{}, // modulesToExclude
		"", // packageJson
		"", // tsconfigJson
		[]string{}, // conditionNames
		FollowMonorepoPackagesValue{}, // followMonorepoPackages
	)

	// Verify each module shows the correct files
	expectedModuleFiles := map[string][]string{
		"@org/scope-module": {"file1.ts", "file3.ts"},
		"test-module":       {"file1.ts", "file2.ts"},
		"simple-module":     {"file2.ts", "file3.ts"},
	}

	for module, expectedFiles := range expectedModuleFiles {
		if !strings.Contains(resultGrouped, module) {
			t.Errorf("Expected module '%s' not found in grouped result", module)
		}
		for _, file := range expectedFiles {
			if !strings.Contains(resultGrouped, file) {
				t.Errorf("Expected file '%s' not found for module '%s' in grouped result", file, module)
			}
		}
	}

	// Test 3: Group by module files count should show correct counts
	resultCount, _ := NodeModulesCmd(
		tempDir,
		false, // ignoreType
		[]string{}, // entryPoints
		false, // countFlag
		false, // listUnused
		false, // listMissing
		false, // groupByModule
		false, // groupByFile
		true, // groupByModuleFilesCount
		[]string{}, // pkgJsonFieldsWithBinaries
		[]string{}, // filesWithBinaries
		[]string{}, // filesWithModules
		[]string{}, // modulesToInclude
		[]string{}, // modulesToExclude
		"", // packageJson
		"", // tsconfigJson
		[]string{}, // conditionNames
		FollowMonorepoPackagesValue{}, // followMonorepoPackages
	)

	expectedCounts := []string{
		"@org/scope-module (2 files)",
		"simple-module (2 files)",
		"test-module (2 files)",
	}

	for _, expected := range expectedCounts {
		if !strings.Contains(resultCount, expected) {
			t.Errorf("Expected count '%s' not found in count result: %s", expected, resultCount)
		}
	}
}

// TestNotResolvedModuleAggregation verifies that NotResolvedModule dependencies
// are also properly aggregated (this was part of the bug)
func TestNotResolvedModuleAggregation(t *testing.T) {
	// Create a temporary test directory
	tempDir, err := os.MkdirTemp("", "not-resolved-aggregation-test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Create package.json (empty - no dependencies)
	pkgJsonContent := `{}`
	pkgJsonPath := filepath.Join(tempDir, "package.json")
	err = os.WriteFile(pkgJsonPath, []byte(pkgJsonContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write package.json: %v", err)
	}

	// Create test files importing non-existent modules with paths
	file1Content := `import "non-existent-module";
import "non-existent-module/src/path1";
import "non-existent-module/lib/utils";
console.log("file1");`
	file1Path := filepath.Join(tempDir, "file1.ts")
	err = os.WriteFile(file1Path, []byte(file1Content), 0644)
	if err != nil {
		t.Fatalf("Failed to write file1.ts: %v", err)
	}

	file2Content := `import "non-existent-module";
import "non-existent-module/src/path2";
console.log("file2");`
	file2Path := filepath.Join(tempDir, "file2.ts")
	err = os.WriteFile(file2Path, []byte(file2Content), 0644)
	if err != nil {
		t.Fatalf("Failed to write file2.ts: %v", err)
	}

	// Test missing modules detection
	result, count := NodeModulesCmd(
		tempDir,
		false, // ignoreType
		[]string{}, // entryPoints
		false, // countFlag
		false, // listUnused
		true, // listMissing
		false, // groupByModule
		false, // groupByFile
		false, // groupByModuleFilesCount
		[]string{}, // pkgJsonFieldsWithBinaries
		[]string{}, // filesWithBinaries
		[]string{}, // filesWithModules
		[]string{}, // modulesToInclude
		[]string{}, // modulesToExclude
		"", // packageJson
		"", // tsconfigJson
		[]string{}, // conditionNames
		FollowMonorepoPackagesValue{}, // followMonorepoPackages
	)

	// Should show only one unique missing module (aggregated)
	expected := "non-existent-module\n"
	if result != expected {
		t.Errorf("Expected aggregated missing module 'non-existent-module' but got: %s", result)
	}

	if count != 1 {
		t.Errorf("Expected count 1, got %d", count)
	}

	// Test grouped by module
	resultGrouped, _ := NodeModulesCmd(
		tempDir,
		false, // ignoreType
		[]string{}, // entryPoints
		false, // countFlag
		false, // listUnused
		true, // listMissing
		true, // groupByModule
		false, // groupByFile
		false, // groupByModuleFilesCount
		[]string{}, // pkgJsonFieldsWithBinaries
		[]string{}, // filesWithBinaries
		[]string{}, // filesWithModules
		[]string{}, // modulesToInclude
		[]string{}, // modulesToExclude
		"", // packageJson
		"", // tsconfigJson
		[]string{}, // conditionNames
		FollowMonorepoPackagesValue{}, // followMonorepoPackages
	)

	// Should show the module with both files
	if !strings.Contains(resultGrouped, "non-existent-module") {
		t.Errorf("Expected 'non-existent-module' in grouped missing result: %s", resultGrouped)
	}
	if !strings.Contains(resultGrouped, "file1.ts") {
		t.Errorf("Expected 'file1.ts' in grouped missing result: %s", resultGrouped)
	}
	if !strings.Contains(resultGrouped, "file2.ts") {
		t.Errorf("Expected 'file2.ts' in grouped missing result: %s", resultGrouped)
	}
}
